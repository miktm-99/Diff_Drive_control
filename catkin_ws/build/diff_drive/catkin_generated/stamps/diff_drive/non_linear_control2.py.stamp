#!/usr/bin/env python

import rospy

import numpy as np

from geometry_msgs.msg import Twist

from nav_msgs.msg import Odometry

from tf.transformations import euler_from_quaternion

import matplotlib.pyplot as plt

from math import atan2, sin, cos, sqrt, pi
 
 
class DiffDriveController:

    def __init__(self):

        rospy.init_node('diff_drive_non_linear_control')
 
        # Parametri del controller

        self.control_rate = rospy.get_param('~control_rate', 30)

        self.max_linear_vel = rospy.get_param('~max_linear_vel', 0.8)

        self.max_angular_vel = rospy.get_param('~max_angular_vel', 1.5)
 
        # Parametri traiettoria

        self.k = rospy.get_param('~k', 8.0)

        self.q_i = np.array(rospy.get_param('~q_i', [0.0, 1.0, 0.0]))

        self.q_f = np.array(rospy.get_param('~q_f', [0.0, -1.0, 0.0]))
 
        self.t_start = rospy.Time.now().to_sec()
 
        # Stato del robot

        self.x = 0.0

        self.y = 0.0

        self.theta = 0.0
 
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)

        self.odom_sub = rospy.Subscriber('/odom', Odometry, self.odom_callback)
 
        self.time_log = []

        self.x_log = []

        self.y_log = []

        self.theta_log = []

        self.xd_log = []

        self.yd_log = []

        self.thetad_log = []

        self.v_log = []

        self.omega_log = []
 
        self.traj_out = self.compute_cubic_trajectory(self.q_i, self.q_f, self.k)
 
        self.control_timer = rospy.Timer(rospy.Duration(1.0/self.control_rate), self.control_loop)
 
    def compute_cubic_trajectory(self, q_i, q_f, k, t=None):

        x_i, y_i = q_i[0], q_i[1]

        x_f, y_f = q_f[0], q_f[1]
 
        if t is not None:

            s = t / t[-1]

            tau = 1 / t[-1]

        else:

            s = np.linspace(0, 1, 200)

            tau = 1
 
        b_x = k * cos(q_i[2]) + 3 * q_i[0]

        b_y = k * sin(q_i[2]) + 3 * q_i[1]

        a_x = k * cos(q_f[2]) - 3 * q_f[0]

        a_y = k * sin(q_f[2]) - 3 * q_f[1]
 
        x = x_f * s**3 - x_i * (s - 1)**3 + a_x * s**2 * (s - 1) + b_x * s * (s - 1)**2

        y = y_f * s**3 - y_i * (s - 1)**3 + a_y * s**2 * (s - 1) + b_y * s * (s - 1)**2
 
        xp = 3 * x_f * s**2 - 3 * x_i * (s - 1)**2 + a_x * (3 * s**2 - 2 * s) + b_x * (s - 1) * (3 * s - 1)

        yp = 3 * y_f * s**2 - 3 * y_i * (s - 1)**2 + a_y * (3 * s**2 - 2 * s) + b_y * (s - 1) * (3 * s - 1)
 
        v = np.sqrt(xp**2 + yp**2)

        theta = np.arctan2(yp, xp)
 
        xpp = 6 * x_f * s - 6 * x_i * (s - 1) + a_x * (6 * s - 2) + b_x * (6 * s - 4)

        ypp = 6 * y_f * s - 6 * y_i * (s - 1) + a_y * (6 * s - 2) + b_y * (6 * s - 4)
 
        w = (ypp * xp - xpp * yp) / (v**2)
 
        return {

            's': s,

            'x': x,

            'y': y,

            'theta': theta,

            'v': v * tau,

            'w': w * tau

        }
 
    def odom_callback(self, msg):

        self.x = msg.pose.pose.position.x

        self.y = msg.pose.pose.position.y

        orientation_q = msg.pose.pose.orientation

        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]

        _, _, self.theta = euler_from_quaternion(orientation_list)
 
    def compute_tracking_error(self, desired_pose):

        theta = self.theta

        R = np.array([

            [cos(theta), sin(theta), 0],

            [-sin(theta), cos(theta), 0],

            [0, 0, 1]

        ])

        current_pose = np.array([self.x, self.y, self.theta])

        pose_error = desired_pose - current_pose

        return np.dot(R, pose_error)
 
    def control(self, e, v_d=None, w_d=None):

        """Controller semplificato basato su errori nel frame robotico"""

        k_v = 0.5

        k_omega_y = 2.0

        k_omega_theta = 1.0
 
        e_x = e[0]

        e_y = e[1]

        e_theta = e[2]
 
        v = k_v * e_x

        omega = k_omega_y * e_y + k_omega_theta * sin(e_theta)
 
        return v, omega
 
    def control_loop(self, event):

        out = self.traj_out

        x_d = out['x']

        y_d = out['y']

        theta_d = out['theta']

        s = out['s']
 
        traj_length = len(s)

        t = rospy.Time.now().to_sec() - self.t_start

        idx = min(int(t * self.control_rate), traj_length - 1)
 
        desired_pose = np.array([x_d[idx], y_d[idx], theta_d[idx]])

        e = self.compute_tracking_error(desired_pose)

        v, w = self.control(e)
 
        v = np.clip(v, -self.max_linear_vel, self.max_linear_vel)

        w = np.clip(w, -self.max_angular_vel, self.max_angular_vel)
 
        cmd_msg = Twist()

        cmd_msg.linear.x = v

        cmd_msg.angular.z = w

        self.cmd_pub.publish(cmd_msg)
 
        self.time_log.append(t)

        self.x_log.append(self.x)

        self.y_log.append(self.y)

        self.theta_log.append(self.theta)

        self.xd_log.append(x_d[idx])

        self.yd_log.append(y_d[idx])

        self.thetad_log.append(theta_d[idx])

        self.v_log.append(v)

        self.omega_log.append(w)
 
    def plot_results(self):

        plt.figure(figsize=(12, 8))
 
        plt.subplot(2, 2, 1)

        plt.plot(self.xd_log, self.yd_log, 'r--', label='Desired')

        plt.plot(self.x_log, self.y_log, 'b-', label='Actual')

        plt.xlabel('x')

        plt.ylabel('y')

        plt.title('Trajectory Tracking')

        plt.legend()

        plt.grid(True)
 
        plt.subplot(2, 2, 2)

        plt.plot(self.time_log, self.xd_log, 'r--', label='x desired')

        plt.plot(self.time_log, self.x_log, 'b-', label='x actual')

        plt.xlabel('Time [s]')

        plt.ylabel('x')

        plt.title('x Tracking')

        plt.legend()

        plt.grid(True)
 
        plt.subplot(2, 2, 3)

        plt.plot(self.time_log, self.yd_log, 'r--', label='y desired')

        plt.plot(self.time_log, self.y_log, 'b-', label='y actual')

        plt.xlabel('Time [s]')

        plt.ylabel('y')

        plt.title('y Tracking')

        plt.legend()

        plt.grid(True)
 
        plt.subplot(2, 2, 4)

        plt.plot(self.time_log, self.v_log, 'g-', label='Linear vel')

        plt.plot(self.time_log, self.omega_log, 'm-', label='Angular vel')

        plt.xlabel('Time [s]')

        plt.ylabel('Velocity')

        plt.title('Control Commands')

        plt.legend()

        plt.grid(True)
 
        plt.tight_layout()

        plt.show()
 
 
if __name__ == '__main__':

    try:

        controller = DiffDriveController()

        rospy.spin()

        controller.plot_results()

    except rospy.ROSInterruptException:

        pass

 
